<html>
<head>
<title>XML-RPC.NET FAQ</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<style type="text/css">
<!--
pre {
 font-family:monospace, arial, verdana;
 font-size: 100%;
 color:black;
 background: #d9e3e9;
 border: 1px black solid ;
 padding: 5px;
}

body {
 font-size: 93%; /* for IE/Win */
 font-family:verdana, arial, sans-serif;
}

html>body {
 font-size: 100%; /* for Opera */
}

H1, H2, H3, H4 {
 font-family:verdana, arial, sans-serif;
}

H1 {
 font-size: 30px;
}

H2 {
  font-size: 110%;
}

H3, H4 {
  font-size: 100%;
}

P.indent {
 margin-left: 5%;
}

-->
</style>

</head>

<body bgcolor="#FFFFFF">
<table width="100%" border="0">
  <tr> 
    <td width="59%"> 
      <h1>XML-RPC.NET FAQ</h1>
    </td>
    <td width="41%"> 
      <h3 align="center"><a href="http://www.cookcomputing.com">Cook Computing</a></h3>
    </td>
  </tr>
</table>
<p>Version 0.97 17th August 2004. &copy; Charles Cook, 2002-2004.</p>
<p>Please send feedback, corrections, etc, to xmlrpcfaq@cookcomputing.com.</p>
<h2>Contents</h2>
<p>1. Introduction</p>
  
<p class="indent">
1.1 <a href="#1.1">What is XML-RPC?</a></br>
1.2 <a href="#1.2">What is XML-RPC.NET?</a><br/>
1.3 <a href="#1.3">Why use XML-RPC instead of SOAP?</a><br/>
1.4 <a href="#1.4">Where do I obtain XML-RPC.NET from?</a><br/>
1.5 <a href="#1.5">How do I install XML-RPC.NET?</a><br/>
1.6 <a href="#1.6">Can I install XML-RPC.NET in the GAC?</a><br/>
1.7 <a href="#1.7">How do I build with XML-RPC.NET?</a><br/>
1.8 <a href="#1.8">How does XML-RPC.NET represent XML-RPC requests and responses?</a><br/>
1.9 <a href="#1.9">How are XML-RPC simple types mapped onto .NET data types?</a><br/>
1.10 <a href="#1.10">How are XML-RPC structs represented as .NET types?</a><br/>
1.11 <a href="#1.11">What if the XML-RPC struct member name is not valid in .NET?</a><br/>
1.12 <a href="#1.12">How are XML-RPC arrays represented as .NET types?</a><br/>
1.13 <a href="#1.13">Is XML-RPC.NET CLS Compliant?</a><br/>
1.14 <a href="#1.14">Why are my struct members ignored?</a></P>

<p>2. Clients</p>
  
<p class="indent">
2.1 <a href="#2.1">How do I implement an XML-RPC client?</a><br/>
2.2 <a href="#2.2">What 
if the XML-RPC method name is not valid in my programming language?<br/>
</a>
2.3 <a href="#2.3">Why does my client throw exception "Invoke on non-existent proxy method"?</a><br/>
2.4 <a href="#2.4">Can I specify the server endpoint URL at runtime?</a><br/>
2.5 <a href="#2.5">How do I set a timeout on a proxy method call?</a><br/>
2.6 <a href="#2.6">How do I supply authentication credentials?</a><br/>
2.7 <a href="#2.7">Can I specify custom HTTP headers?</a> <br/>
2.8 <a href="#2.8">Why does the method name have to be hard-coded in each proxy method?</a><br/>
2.9 <a href="#2.9">How do I make an asynchronous XML-RPC request?</a><br/>
2.10 <a href="#2.10">How do I poll for the result of an asynchronous call?</a><br/>
2.11 <a href="#2.11">How do I receive a callback on completion of an asynchronous call?</a><br/>
2.12 <a href="#2.12">What is the asyncState parameter used for?</a><br/>
2.13 <a href="#2.13">How do I implement a client in VB.NET?</a><br/>
2.14 <a href="#2.14">Why doesn't the following code cause an exception?</a><br/>
2.15 <a href="#2.15">How do I implement a client in Managed C++?</a><br/>
2.16 <a href="#2.16">How do I implement a client in JScript.NET?</a><br/>
2.17 <a href="#2.17">Do classes derived from XmlRpcClientProtocol support the Introspection API?</a><br/>
2.18 <a href="#2.18">Can I define a proxy method to return void?</a><br/>
2.19 <a href="#2.19">Does XmlRpcClientProtocol.Invoke use params for the array of parameters?</a> <br/>
2.20 <a href="#2.20">How do I specify a proxy server when making an XML-RPC request?</a> </p>
  
<p>3. Servers</p>
  
<p class="indent">
3.1 <a href="#3.1">What are the different ways in which an XML-RPC server can be implemented?</a><br/>
3.2 <a href="#3.2">How do I implement an XML-RPC server in IIS?</a><br/>
3.3 <a href="#3.3">How do I implement an XML-RPC server using .NET Remoting?</a><br/>
3.4 <a href="#3.4">How do I implement an XML-RPC server in IIS using .NET Remoting?</a><br/>
3.5 <a href="#3.5">Do XML-RPC.NET servers implement the XML-RPC Introspection API?</a><br/>
3.6 <a href="#3.6">What is Automatic Documentation?</a><br/>
3.7 <a href="#3.7">How do I support authentication in my XML-RPC service?</a><a href="#How_do_I_support_authentication_in_my_XML-RPC_service"><br/>
  </a> 
3.8 <a href="#3.8">Can I implement a server which supports both XML-RPC and SOAP?</a><br/>
3.9 <a href="#3.9">Can I run XML RPC.NET services with other web servers</a>?<br/>
3.10 <a href="#3.10">Can I implement services in other languages?</a>?<br/>
3.11 <a href="#3.11">Can I implement a service in an ASHX file?</a>?<br/>
</p>

<p>4. Error Handling</p>
  
<p class="indent">4.1 <a href="#4.1">How are 
XML-RPC Fault Responses represented?</a><br/>
4.2 <a href="#4.2">How are other types of error returned?</a><br/>
4.3 <a href="#4.3">What happens if the return value of a proxy method is incorrect?</a> </p>
  
<p>5. Debugging</p>

<p class="indent">
5.1 <a href="#5.1">How do I monitor XML-RPC calls across the network?</a><br/>
5.2 <a href="#5.2">How do I debug an XML-RPC.NET service</a>?
</p>

<p>6. Miscellaneous</p>

<p class="indent">
6.1 <a href="#6.1">Which XML Encodings are Supported?</a><br/>
6.2 <a href="#6.2">Which Code Access Security Permissions are Required?</a><br/>
6.3 <a href="#6.3">Why is the key file not included in the distribution?</a><br/>
6.4 <a href="#6.4">How do I verify an XML-RPC.NET assembly is genuine?</a><br/>
6.5 <a href="#6.5">Can I define an interface from which both the proxy and server classes are derived?</a>
</p>
  
<p>7. Resources</p>
  
<p class="indent">
7.1 <a href="#7.1">XML-RPC Specification</a><br/>
7.2 <a href="#7.2">Books</a><br/>
7.3 <a href="#7.3">Websites</a><br/>
7.4 <a href="#7.4">Mailing Lists</a><br/>
7.5 <a href="#7.5">Articles and Tutorials</a><br/>
7.6 <a href="#7.6">Sample Services</a>
</p>


<h2>1. Introduction</h2>

<h3><a name="1.1"></a>1.1 What is XML-RPC?</h3>

<p>
To quote the XML-RPC.Com site:
</p>

<p>
"It's a spec and a set of implementations that allow software running 
on disparate operating systems, running in different environments to make procedure 
calls over the Internet. It's remote procedure calling using HTTP as the transport 
and XML as the encoding. XML-RPC is designed to be as simple as possible, while 
allowing complex data structures to be transmitted, processed and returned.";
</p>


<h3><a name="1.2"></a>1.2 What is XML-RPC.NET?</h3>
<p>
XML-RPC.NET is a .NET class library for implementing XML-RPC clients and servers. 
</p>


<h3><a name="1.3"></a>1.3 Why use XML-RPC instead of SOAP?</h3>

<p>
If your clients and servers are all running in the .NET environment there is 
no point in using XML-RPC: .NET provides excellent support for SOAP and XML-RPC 
doesn't have any features not provided by SOAP.
</p>

<p>
If you use .NET clients and want to connect to XML-RPC servers running under 
any OS then XML-RPC.NET is a good choice.
</p>

<p>
If you want to implement a server in the .NET environment which is to be connected 
to by clients running in other environments, say Unix or Java, then XML-RPC 
may be an appropriate choice. SOAP is supported in many different environments 
but is considerably more complicated than XML-RPC and presents more chance of 
interop problems.
</p>


<h3><a name="1.4"></a>1.4 Where do I obtain XML-RPC.NET from?</h3>

<p>
XML-RPC.NET can be obtained from the XML-RPC.NET <a href="http://www.xml-rpc.net/">home 
page</a>.
</p>

<p>
Updates are announced at <a href="http://www.cookcomputing.com/">Cook Computing</a> 
and the Yahoo <a href="http://groups.yahoo.com/XMLRPCNET/">XMLRPCNET</a> group.
</p>


<h3><a name="1.5"></a>1.5 How do I install XML-RPC.NET?</h3>

<p>
XML-RPC.NET is distributed as a single assembly called <b>CookComputing.XmlRpc.dll</b> 
which contains both client and server classes. When used by another program, 
installation is simply a matter of ensuring that the assembly is in the same 
directory as the program using it or referred to using the program's config 
file if in another directory.
</p>

<p>
In the case of an XML-RPC web service running in IIS, the CookComputing.XmlRpc.dll 
assembly is placed in the bin sub-directory of the virtual directory which is 
being used for the web service.<font size="-1"> </font>
</p>

<h3><a name="1.6"></a>1.6 Can I install XML-RPC.NET in the GAC?</h3>

<p>
XML-RPC.NET is built with a strong name and so can be added to the Global Assembly 
Cache (GAC). To do this use the gacutil utility: 
</p>

<pre>gacutil /i CookComputing.XmlRpc.dll</pre>

<p>
Alternatively the dll can be dragged and dropped into the winnt\assembly directory 
using Windows Explorer.
</p>


<h3><a name="1.7"></a>1.7 How do I build with XML-RPC.NET?</h3>

<p>
When compiling code which uses any of the classes in the XML-RPC.NET assembly, 
a reference to the assembly must be specified. 
</p>

<p>In Visual Studio .NET this is is achieved by using the References dialog which 
is invoked from the References item in the Solution Explorer. If compiling with 
the csc.exe compiler, the XmlRpc assembly is referenced like this:
</p>

<pre>csc /r:CookComputing.XmlRpc.dll myprogram.cs</pre>


<h3><a name="1.8"></a>1.8 How does XML-RPC.NET represent XML-RPC requests and responses?</h3>
<p>
XML-RPC.NET represents each XML-RPC server endpoint on both client and server 
sides using custom classes which have a number of public methods, each method 
representing one of the XML-RPC methods of the endpoint. The methods on the 
server side class implement the functionality of the endpoint and the methods 
on the client side class act as proxy methods.
</p>

<p>
For example, the server side class implementing the sumAndDifference API could 
be coded like this:
</p>

<pre>struct SumAndDiffValue 
{
  public int sum; 
  public int difference; 
}


class SumAndDiffService : XmlRpcService
{ 
  [XmlRpcMethod("sample.sumAndDifference")] 
  public SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    SumAndDiffValue ret; 
    ret.sum = x + y; 
    ret.difference = x – y; 
    return ret; 
  } 
}</pre>

<p>
The corresponding client side proxy class could look like this:
</p>

<pre>[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
class SumAndDiffProxy : XmlRpcClientProtocol 
{ 
  [XmlRpcMethod("sample.sumAndDifference")] 
  SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    return (SumAndDiffValue)Invoke("SumAndDifference", 
                                   new Object[]{ x, y }); 
  } 
} </pre>

<p>
A client would use the proxy class like this:
</p>

<pre>SumAndDiffProxy proxy = new SumAndDiffProxy(); 
SumAndDiffValue ret = proxy.SumAndDifference(2, 3); </pre>


<h3><a name="1.9"></a>1.9 How are XML-RPC simple types mapped onto .NET data types?</h3>

<p>
XML-RPC simple types are mapped to and from the following .NET types: 
</p>

<table width="100%" border="1" cellpadding="5" cellspacing="0" >
  <tr> 
    <td width="25%">&lt;i4&gt; or &lt;int&gt;</td>
    <td width="25%">System.Int32</td>
    <td>XML-RPC.NET always outputs &lt;i4&gt;</td>
  </tr>
  <tr> 
    <td width="25%">&lt;boolean&gt;</td>
    <td width="25%">System.Boolean</td>
    <td>&nbsp;</td>
  </tr>
  <tr> 
    <td width="25%">&lt;string&gt;</td>
    <td width="25%">System.String</td>
    <td>XML-RPC.NET always outputs the &lt;string&gt; element instead of just 
      a &lt;value&gt; element with text content</td>
  </tr>
  <tr> 
    <td width="25%">&lt;double&gt;</td>
    <td width="25%">System.Double</td>
    <td>&nbsp;</td>
  </tr>
  <tr> 
    <td width="25%">&lt;dateTime.iso8601&gt;</td>
    <td width="25%">System.DateTime</td>
    <td>Note that the format used in XML-RPC -<font face="Courier New, Courier, mono" size="-1">YYYYMMDDTHH:mm:SS</font> 
      - is not one of the formats described in the ISO8601 specification</td>
  </tr>
  <tr> 
    <td width="25%">&lt;base64&gt;</td>
    <td width="25%">System.Byte[]</td>
    <td>&nbsp;</td>
  </tr>
</table>


<h3><a name="1.10"></a>1.10 How are XML-RPC structs represented as .NET types?</h3>

<p>
An XML-RPC struct is a dictionary of name+member pairs and so is much more 
flexible than a struct in C++ or C#. Depending on the particular XML-RPC method, 
the members of a struct are not necessarily fixed: a struct might contain a 
fixed set of members, a subset of a known set of members, or even an arbitrary 
set of members created at runtime. 
</p>

<p>
For cases where the members of the struct are fixed, the XML-RPC struct can 
be mapped onto a .NET struct, for example:
</p>

<pre>&lt;struct&gt;
  &lt;member&gt;
    &lt;name&gt;code&lt;/name&gt;
    &lt;value&gt;&lt;int&gt;2&lt;/int&gt;&lt;/value&gt;
  &lt;/member&gt;
  &lt;member&gt;
    &lt;name&gt;description&lt;/name&gt;
    &lt;value&gt;&lt;string&gt;File missing.&lt;/string&gt;&lt;/value&gt;
  &lt;/member&gt;
&lt;/struct&gt;</pre>

<p>
could map onto this C# struct:<br/>
</p>

<pre>struct errStruct<br/>{
  public int code;
  public string description;
}</pre>

<p>
When mapping from an XML-RPC struct to a .NET struct, XML-RPC.NET ignores any 
members which are only in the XML-RPC struct, but throws an exception if a member 
is defined in the .NET struct but is not in the XML-RPC struct.
</p>

<p>
When mapping from a .NET struct to an XML-RPC struct, XML-RPC.NET simply maps 
every member of the .NET struct to the XML-RPC struct.
</p>

<p>In cases where the usage of the struct in the XML-RPC call is too flexible 
to be represented by a fixed data type, the XmlRpcStruct type can be used. This 
is a derivation of the .NET hashtable type and consists of name/member pairs 
representing the members of the XML-RPC struct. For example:
</p>

<pre>XmlRpcStruct bounds = new XmlRpcStruct();
bounds.Add(&quot;lowerBound&quot;, 18);
bounds.Add(&quot;upperBound&quot;, 139);<br/>...<br/>lowerBound = (int)bounds[&quot;lowerBound&quot;];<br/>upperBound = (int)bounds[&quot;upperBound&quot;];</pre>


<h3><a name="1.11"></a>1.11 What if the XML-RPC struct member name is not valid in .NET?</h3>

<p>
In some cases the name of a member in an XML-RPC struct might be invalid in 
the .NET programming language being used. To handle this the XmlRpcMember attribute 
is available. This allows an XML-RPC member name to be mapped to and from a 
different .NET name. For example:
</p>

<pre>public struct SumAndDiffValue
{ 
  [XmlRpcMember("sample.sum")] 
  public int sum; 
  [XmlRpcMember("sample.difference")] 
  public int difference; 
}</pre>


<h3><a name="1.12"></a>1.12 How are XML-RPC arrays represented as .NET types?</h3>

<p>
Where possible XML-RPC.NET maps XML-RPC arrays onto arrays of .NET types. Where 
this is not possible, for example where the members of the XML-RPC array are 
not of the same type, the mapping is to an instance of System.Object[].
</p>

<p>
XML-RPC.NET does not support &quot;jagged&quot; arrays - arrays of arrays - 
because these are not CLS compliant.
</p>


<h3><a name="1.13"></a>1.13 Is XML-RPC.NET CLS Compliant?</h3>

<p>
XML-RPC.NET is fully Common Language Specification (CLS) compliant. This means 
that it can be used from any .NET language which is also CLS compliant, for 
example C#, VB.NET, or Managed Extensions for C++.
</p>


<h3><a name="1.14"></a>1.14 Why are my struct members ignored?</h3>

<p>
A common mistake with structs is to define them like this in C#:
</p>

<pre>struct SumAndDiffValue
{ 
  int sum;
  int difference; 
}</pre>

<p>
or like this in VB.NET:
</p>

<pre>Public Structure SumAndDiffValue
  sum As Integer 
  difference As Integer 
End Structure</pre>

<p>
The mistake is that the members are not defined as public. This means the XML-RPC.NET 
library cannot recognize them without requiring extra security permissions associated 
with reflection. This might not be available in all circumstances, for example 
where the XML-RPC.NET assembly is downloaded by a client running in the Internet 
security zone, and so struct members are required to have public visibility. 
To take the C# case, the correct version of the struct would be: 
</p>

<pre>struct SumAndDiffValue
{ 
  public int sum;
  public int difference; 
}</pre>


<h2>2. Clients</h2>


<h3><a name="2.1"></a>2.1 How do I implement an XML-RPC client?</h3>


<p>
To make calls to an XML-RPC server it is necessary to use a proxy class. There 
are two ways of implementing this: using the XmlRpcProxyGen class to build a 
proxy class dynamically, or by manually coding the class.
</p>


<h4>Using XmlRpcProxyGen</h4>

<p>
First devise an interface which represents the methods of XML-RPC server endpoint. 
For example:
</p>

<pre>using CookComputing.XmlRpc;

struct SumAndDiffValue 
{
  public int sum; 
  public int difference; 
}

[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
interface ISumAndDiff
{ 
  [XmlRpcMethod] 
  SumAndDiffValue SumAndDifference(int x, int y);
} 
</pre>

<p>
Second, create an instance of a dynamically created proxy class:
</p>

<pre>ISumAndDiff proxy = (ISumAndDiff)XmlRpcProxyGen.Create(typeof(ISumAndDiff));</pre>

<p>
Third, call a method on the interface:
</p>

<pre>SumAndDiffValue ret = proxy.SumAndDifference(2, 3);</pre>


<h4>Manually Coding a Proxy Class</h4>

<p>
If the XmlRpcProxyGen class is not used to create the proxy class, the class 
must be coded manually.
</p>

<pre>using CookComputing.XmlRpc;

struct SumAndDiffValue 
{
  public int sum; 
  public int difference; 
}

[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
class SumAndDiffProxy : XmlRpcClientProtocol 
{ 
  [XmlRpcMethod] 
  SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    return (SumAndDiffValue)Invoke("SumAndDifference", 
                                   new Object[]{ x, y }); 
  } 
} 
</pre>

<p>
The using statement is for convenience so the XmlRpc types don't have to be 
qualified by namespace.
</p>

<p>
The SumAndDiffValue is defined to represent the result of the sample.sumAndDifference 
XML-RPC call. Each member of the struct represents a member of the XML-RPC struct 
returned by the call. Note that members must be defined as public.
</p>

<p>
The XmlRpcUrl attribute is applied to the proxy class to specify the URL of 
  the server endpoint.
</p>

<p>
The class being defined derives from XmlRpcClientProtocol to inherit the required 
proxy functionality.
</p>

<p>Each method representing an XML-RPC method is marked with the XmlRpcMethod 
attribute.
</p>

<p>
The SumAndDifference method is defined to represent the XML-RPC call. The member 
function Invoke (inherited from XmlRpcClientProtocol) is called, passing the 
name of the current function and the parameters to the call in an array of type 
Object. The value returned from Invoke is cast to the required return type for 
the function and returned.
</p>

<p>
Note that the first parameter to invoke is always the name of the proxy function, 
<b>NOT</b> the name of the XML-RPC method - the next question describes situations 
  in which these names are different (the above code assumes the XML-RPC method 
  name is SumAndDifference).
</p>

<p>
Use the proxy class like this:
</p>

<pre>SumAndDiffProxy proxy = new SumAndDiffProxy();
SumAndDiffValue ret = proxy.SumAndDifference(2, 3);</pre>


<h3><a name="2.2"></a>2.2 What if the XML-RPC method name is not valid in my programming language?</h3>

<p>
Sometimes the XML-RPC method name cannot be used as a method name in the proxy 
class. For example, it is common practice for XML-RPC method names to have the 
form <i>namespace.methodname</i>, such as <i>sample.SumAndDifference</i> In 
these cases a different constructor is used for the XmlRpcMethod attribute, 
taking a string which specifies the XML-RPC method name. For example:
</p>

<pre>[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
class SumAndDiffProxy : XmlRpcClientProtocol 
{ 
  [XmlRpcMethod("sample.sumAndDifference")] 
  SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    return (SumAndDiffValue)Invoke("SumAndDifference", <br/>                                   new Object[]{ x, y }); 
  } 
}
</pre>


<h3><a name="2.3"></a>2.3 Why does my client throw exception &quot;Invoke on non-existent proxy method&quot;?</h3>

<p>
When manually implementing a proxy method there are two method names involved: 
the name of the proxy method and the name of the XML-RPC method. As the previous 
answer explained, these names are not necessarily the same, and if the first 
parameter of Invoke is the XML-RPC method name, and not the proxy method name, 
an exception is thrown with the message: &quot;Invoke on non-existent proxy 
method&quot;. This problem can be avoided by following these rules:
</p>

<ol>
<li>
The call to <b>Invoke</b> always passes the name of the <b>proxy method</b>. 
</li>
<li>If the the name of XML-RPC method is not the same as the name of the proxy 
method, the <b>XML-RPC method</b> name is specified by passing it to the <b>XmlRpcMethod 
attribute</b>.
</li>
</ol>

<p>
The reason for this is that there are two stages of serialization when making 
an XML-RPC call. The first is performed by the implementation of the proxy method, 
converting the call into a method name and an array of type Object which contains 
the parameters.This representation of the call is then passed to the XmlRpcClientProtocol 
class using the Invoke method. The second stage is when the method name and 
parameter array are converted into the XML request. 
</p>

<p>
For the second stage to work effectively it needs to how the parameters should 
be mapped onto the params element of the XML request and what method name should 
be specified in the methodCall element. The first point is handled by using 
reflection on the proxy method, hence the need for the proxy method name, and 
the second point is handled by using the name specified in the XmlRpcMethod 
attribute (or the proxy method name if a name is not specified in the attribute).</p>


<h3><a name="2.4"></a>2.4 Can I specify the server endpoint URL at runtime?</h3>

<p>
Yes, classes derived from XmlRpcClientProtocol inherit a Url property. This 
means that the XmlRpcUrl attribute can be omitted from the definition of the 
proxy class and instead the Url property is then set on an instance of the class:</p>

<pre>SumAndDiffProxy proxy = new SumAndDiffProxy(); 
proxy.Url = &quot;http://www.cookcomputing.com/SumAndDiff.rem&quot;);
SumAndDiffValue ret = proxy->SumAndDifference(2, 3);
</pre>


<h3><a name="2.5"></a>2.5 How do I set a timeout on a proxy method call?</h3>

<p>
Classes derived from XmlRpcClientProtocol inherit a Timeout property. This 
takes an integer which specifies the timeout in milliseconds. For example, to 
set a 5 second timeout:
</p>


<pre>SumAndDiffProxy proxy = new SumAndDiffProxy(); 
proxy.Timeout = 5000;
SumAndDiffValue ret = proxy->SumAndDifference(2, 3);</pre>


<h3><a name="2.6"></a>2.6 How do I supply authentication credentials?</h3>

<p>
Classes derived from XmlRpcClientProtocol inherit a Credentials property. This 
is used where the XML-RPC server authenticates the caller. The property is used 
in exactly the same way as the same property of the System.Net.WebRequest class. 
For example:
</p>

<pre>SumAndDiffProxy proxy = new SumAndDiffProxy(); 
proxy.Credentials = new NetworkCredential("jsmith","password");
SumAndDiffValue ret = proxy->SumAndDifference(2, 3);
</pre>


<h3><a name="2.7"></a>2.7 Can I specify custom HTTP headers? </h3>

<p>
Yes, classes derived from XmlRpcClientProtocol inherit a Headers property of 
type WebHeaderCollection. This can be used to specify custom headers which will 
be added to the HTTP request. For example:
</p>

<pre>SumAndDiffProxy proxy = new SumAndDiffProxy(); 
proxy.Headers.Add("TestHeader", "this_is_a_test");
SumAndDiffValue ret = proxy->SumAndDifference(2, 3);
</pre>


<h3><a name="2.8"></a>2.8 Why does the method name have to be hard-coded in each proxy method?</h3>

<p>
It might seem superfluous and error-prone to supply the name of the method 
name in each call to Invoke and indeed it is relatively trivial to code around 
this or even generate a proxy object automatically. However if one of these 
approaches were taken the client would need extra Code Access Security permissions 
which would prevent the XML-RPC.NET library being used unless full trust were 
given to the client code. The library is intended to be useful in as many situations 
as possible, for example with downloadable &quot;smart&quot;, clients and so 
the extra effort involved in using Invoke is considered worthwhile.<br/>
</p>


<h3><a name="2.9"></a>2.9 How do I make an asynchronous XML-RPC request?</h3>

<p>
Although XML-RPC itself only supports synchronous method calls, XML-RPC.NET 
has support for asynchronous calls on proxy classes. As with synchronous calls 
there are twp approaches to implementing a proxy with asynchronous calls: using 
the XmlRpcProxyGen class to build the proxy automatically or implementing the 
proxy by hand.</p>

<p>
There are two ways of handling asynchronous calls: polling to determine when 
the call has completed, and using a delegate to receive a callback when the 
call has completed.These are discussed in the following answers.
</p>


<h4>Using XmlRpcProxyGen</h4>

<p>
The interface which represents the methods of XML-RPC server endpoint is extended 
with Begin and End methods for each XML-RPC method to be called asynchronously. 
Two attributes are used for this, the XmlRpcBeginAttribute, which is used to 
indicate which methods used to start async calls, and the XmlRpcEndAttribute, 
which is used to indicate methods which end async calls. For example:
</p>

<pre>using CookComputing.XmlRpc;

struct SumAndDiffValue 
{
  public int sum; 
  public int difference; 
}

[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")] 
interface ISumAndDiff
{ 
  [XmlRpcMethod] 
  SumAndDiffValue SumAndDifference(int x, int y);<br/>
&nbsp;&nbsp;[XmlRpcBegin]
&nbsp;&nbsp;IAsyncResult BeginSumAndDifference(int x, int y);

&nbsp;&nbsp;[XmlRpcEnd]<br/>&nbsp;&nbsp;SumAndDiffValue EndSumAndDifference(IAsyncResult iasr);
} </pre>

<p>
The name of each Begin method is the name of the XML-RPC method name prefixed 
by &quot;Begin&quot;: the XML-RPC.NET runtime code strips off the &quot;Begin&quot; 
to determine the name of the XML-RPC method to be called. In the case where 
the XML-RPC method name prefixed by &quot;Begin&quot; is not suitable, a different 
XmlRpcBeginAttribute constructor can be used to specify the XML-RPC method name. 
For example:
</p>

<pre>&nbsp;&nbsp;[XmlRpcBegin(&quot;sample.sumAndDifference&quot;)] <br/>&nbsp;&nbsp;IAsyncResult BeginSumAndDifference(int x, int y); </pre>

<p>
The name of each End method is not used in the same way - all that matters 
is that the parameter is IAsyncResult and the return value represents the return 
value of the corresponding XML-RPC method. However it is worth following following 
the convention that the name is similar to the name of the corresponding Being 
method, with &quot;End&quot; replacing the &quot;Being&quot; prefix.
</p>

<p>Where a callback is required when the method completes it is necessary to pass 
a callback delegate to the method. 
</p>

<pre>&nbsp;&nbsp;[XmlRpcBegin] <br/>&nbsp;&nbsp;IAsyncResult BeginSumAndDifference(int x, int y, AsyncCallback acb); </pre>

<p>
The AsyncCallback parameter must follow all the normal parameters to the method. 
Finally, where some state is required to be held during the async call, for 
example where the same callback delegate is being used to handle multiple calls 
and the target of the delegate has to distinguish between calls, another parameter 
can be specified to pass the state into the call. This is of type System.Object 
and must follow the AsyncCallback parameter, for example:
</p>

<pre>&nbsp;&nbsp;[XmlRpcBegin] <br/>&nbsp;&nbsp;IAsyncResult BeginSumAndDifference(int x, int y, AsyncCallback acb, object state); 
</pre>

<p>
If a proxy async method has been defined with the AsyncCallback parameter and/or 
the state parameter and they are not required in a call they can be passed as 
null. <br/>
</p>


<h4>Manually Coding a Proxy Class</h4>

<p>
For cases where a manually implemented proxy is require it is possible to make 
asynchronous calls via the BeginInvoke and EndInvoke methods of XmlRpcClientProtocol. 
</p>

<p>
In both cases two new methods must be implemented in the proxy class for each 
XML-RPC method. For example:
</p>

<pre>[XmlRpcUrl("http://www.cookcomputing.com/sumAndDiff.rem")]
class SumAndDiffProxy : XmlRpcClientProtocol 
{
  [XmlRpcMethod("sample.sumAndDifference")] 
  SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    return (SumAndDiffValue)Invoke("SumAndDifference", new Object[]{ x, y }); 
  } 
   
  public IAsyncResult BeginSumAndDifference(int x, int y, AsyncCallback callback,    
                                            object asyncState) 
  { 
    return BeginInvoke("SumAndDifference", new object[]{x, y}, callback, asyncState);    
  } 

  public Result EndSumAndDifference(IAsyncResult asr) 
  { 
    return (Result)EndInvoke(asr)[0]; 
  } 
} </pre>


<h3><a name="2.10"></a>2.10 How do I poll for the result of an asynchronous call?</h3>

<p>
When polling the last two parameters of BeginSumAndDifference are not required 
and can be passed as null. The asynchronous call would begin like this: 
</p>

<pre>IAsyncResult asr;<br/>asr = proxy.BeginSumAndDifference(5, 3, null, null); </pre>

<p>
An instance of the IAsyncResult is returned. This has several public properties, 
the interesting one for polling being the boolean property IsCompleted. The 
value of this property can be checked as required until is found to be true, 
for example: 
</p>

<pre>while (asr.IsCompleted == false) 
{ 
  Thread.Sleep(1000); 
} </pre>

<p>
Once the call has completed the result of the call can be obtained by calling 
EndSumAndDifference, passing in the instance of IAsyncResult returned from the 
call to BeginSumAndDifference: 
</p>

<pre>try 
{ 
  Result ret = theProxy.EndSumAndDifference(asr); 
} 
catch(Exception ex) 
{ 
  // handle the exception 
} </pre>

<p>
Note that a try-catch block is placed around the call to EndSumAndDifference. 
This is because any exceptions thrown during the asynchronous processing of 
the call, for example a network error or because the server returned a Fault 
Response, are stored until the XmlRpcClientProtocol method EndInvoke is called, 
at which point the the exception is rethrown. 
</p>


<h3><a name="2.11"></a>2.11 How do I receive a callback on completion of an asynchronous call?</h3>

<p>
When a callback approach is used, a method must be defined and used with a 
delegate to take the callback:
</p>

<pre>void SumAndDiffCallback(IAsyncResult asr) 
{ 
  try 
  { 
    SumAndDiffProxy proxy = (SumAndDiffProxy)ar.AsyncObject; 
    Result ret = proxy.EndSumAndDifference(asr); 
  } 
  catch(Exception ex) 
  { 
    // handle the exception 
  } 
} </pre>

<p>
This time when calling BeginSumAndDifference an AsyncCallback delegete must 
be created and passed into the call:
</p>

<pre>AsyncCallback acb = new AsyncCallback(SumAndDiffCallback);
theProxy.BeginSumAndDifference(5, 3, acb, null); </pre>

<p>
The IAsyncResult returned from the call is ignored because all further handling 
of the call is done via the callback. When the call is completed, the callback 
method is called and, as its implementation suggests, the original SumAndDiffProxy 
used to make the call is retrieved from the AsyncObject property of the IAsyncResult 
interface so that the EndSumAndDifference method can be called to retrieve the 
result. 
</p>

<h3><a name="2.12"></a>2.12 What is the asyncState parameter used for?</h3>

<p>
The fourth parameter to BeginInvoke and the proxy methods that call this method 
is an object which can optionally be used to hold some state during the lifetime 
of the asynchronous call. In many cases this will be unnecessary and can be 
passed as null.
</p>


<h3><a name="2.13"></a>2.13 How do I implement a client in VB.NET?</h3>

<p>
The client implemented in C# in section 2.1 can be implemented similarly in 
  VB.NET: 
</p>

<pre>Imports CookComputing.XmlRpc<br/>Module SumAndDiffSample<br/>
  Public Structure SumAndDiffValue
    Public sum As Integer
    Public difference As Integer
  End Structure<br/>
  &lt;XmlRpcUrl(&quot;http://www.cookcomputing.com/sumAndDiff.rem&quot;)&gt; _
  Public Class SumAndDiffProxy
    Inherits XmlRpcClientProtocol<br/>    &lt;XmlRpcMethod(&quot;sample.sumAndDifference&quot;)&gt; _
    Public Function SumAndDifference(ByVal x As Integer, _
                                     ByVal y As Integer) _
                                     As SumAndDiffValue
      Return Invoke(&quot;SumAndDifference&quot;, New Object() { x , y })
    End Function
  End Class

  Sub Main()
    Dim proxy As New SumAndDiffProxy()
    Dim strct As New SumAndDiffValue()
    proxy.SumAndDifference(2, 3)
  End Sub

End Module
</pre>

<h3><a name="2.14"></a>2.14 Why does the following VB code cause an exception?</h3>

<p>
When using arrays in VB the following mistake is easy to make and will cause 
an exception at runtime:
</p>

<pre>XmlRpcMethod(&quot;db.listCollections&quot;)_
Public Function listCollections(ByVal name As String) As String()
  Dim coll() As String = {}
  Dim param(1) As Object
  param(0) = New String(name)
  coll = Invoke(&quot;listCollections&quot;, param)
  Return coll
End Function</pre>

<p>
The line defining param actually defines an array with two elements, the first 
element being the required string, the second element being null. It should 
be correctly coded as:
</p>

<pre>Dim param(0) As Object</pre>


<h3><a name="2.15"></a>2.15 How do I implement a client in Managed C++?</h3>

<p>
<i>TBD</i>
</p>


<h3><a name="2.16"></a>2.16How do I implement a client in JScript.NET?</h3>

<p>
<i>TBD</i>
</p>


<h3><a name="2.17"></a>2.17 Do classes derived from XmlRpcClientProtocol support the Introspection API?</h3>

<p>
Yes, support for the XML-RPC Introspection API is built into the XmlRpcClientProtocol 
class. Any class derived from XmlRpcClientProtocol or just an instance of XmlRpcClientProtocol 
can be used to make Introspection requests. 
</p>

<p>
Three public methods expose the three methods of the API: 
</p>
<ul>
  <li>System.String[] SystemListMethods() </li>
  <li> System.Object[] SystemMethodSignature(System.String MethodName)</li>
  <li> System.String SystemMethodHelp(System.String MethodName) </li>
</ul>

<p>
SystemListMethods is used to call the system.listMethods method on the server. 
It simply returns an array of strings containing the XML-RPC names of the methods 
supported by this endpoint on the server.
</p>

<pre>string[] methods = proxy.ListMethods();</pre>

<p>
SystemMethodSignature is used to call the system.methodSignature method on 
the server. It returns an array of Object, each member of the array being an 
instance of an array of strings. This could have been represented more accurately 
as a jagged array - System.String[][] - but jagged arrays are not CLS compliant. 
</p>

<pre>object[] signatures = proxy.SystemMethodSignature("sample.sumAndDifference"); 
foreach (string[] signature in signatures) 
  foreach (string param in signature)<br/>  	Console.WriteLine(param); 
</pre>

<p>
Finally, SystemMethodHelp calls the system.methodHelp method on the server 
and returns a help string for the specified method.
</p>

<pre>string s = proxy.SystemMethodHelp("sample.sumAndDifference");
</pre>


<h3><a name="2.18"></a>2.18 Can I define a proxy method to return void?</h3>

<p>
XML-RPC methods must always return a value. However there are some situations 
in which an XML-RPC method would have been defined to return void if this were 
possible and in these cases a dummy value may be returned, for example an empty 
string. The proxy method could be defined to return a corresponding type but 
it is perhaps more clear to specify the method as returning void, in which case 
the dummy return value is discarded. For example:
</p>

<pre> [XmlRpcMethod] void SumAndDifference(int x, int y);</pre>


<h3><a name="2.19"></a>2.19 Does XmlRpcClientProtocol.Invoke use params for the array of parameters?</h3>

<p>
When calling XmlRpcClientProtocol.Invoke, the parameter which passes the array 
of method parameters is defined with the params keyword. This means that instead 
of calling Invoke with an explcitly declared array of type object[], we can 
pass the method parameters as individual parameters to Invoke. For example, 
this proxy method:
</p>

<pre>[XmlRpcMethod] SumAndDiffValue SumAndDifference(int x, int y)
{
  return (SumAndDiffValue)Invoke("SumAndDifference", new Object[]{ x, y }); 
} </pre>

<p>
can be coded as:
</p>

<pre>[XmlRpcMethod] SumAndDiffValue SumAndDifference(int x, int y)
{
  return (SumAndDiffValue)Invoke("SumAndDifference", x, y); 
} 
</pre>


<h3><a name="2.20"></a>2.20 How do I specify a proxy server when making an XML-RPC request?</h3>

<p>
Sometimes the XML-RPC client is behind a firewall and must send requests via 
a proxy server. There are two methods of achieving this with XML-RPC.NET. 
</p>

<p>The first method is to set the Proxy property of the proxy class. In a similar 
way to setting the Proxy property of an instance of class System.Net.WebRequest, 
the property is set to an instance of the IWebProxy interface, this usually 
being the interface on an instance of the System.Net.WebProxy class. For example:
</p>

<pre>SumAndDiffProxy xmlRpcProxy = new SumAndDiffProxy();
xmlRpcProxy.Proxy = new WebProxy(&quot;http://proxyserver:8000&quot;);    
SumAndDiffValue ret = xmlRpcProxy->SumAndDifference(2, 3); </pre>

<p>The second method is to set a global default proxy for all requests by using 
the System.Net.GlobalProxySelection class:
</p>

<pre>GlobalProxySelection.Select = &quot;http://proxyserver:8000&quot;;</pre>


<h2>3. Servers</h2>


<h3><a name="3.1"></a>3.1 What are the different ways in which an XML-RPC server can be implemented?</h3>

<p>
There are three ways of implementing an XML-RPC server using XML-RPC.NET:
</p>

<ol>
  <li>In IIS using a class derived from XmlRpcService.</li>
  <li>Using an XML-RPC formatter with .NET Remoting.</li>
  <li>In IIS using an XML-RPC formatter with .NET Remoting.</li>
</ol>


<h3><a name="3.2"></a>3.2 How do I implement an XML-RPC server in IIS?</h3>

<p>
Class XmlRpcService implements an HTTP Handler which exposes the IHttpHandler 
and IRequiresSessionState interfaces. When a class derived from XmlRpcService 
is configured via a web.config file, incoming XML-RPC requests will be directed 
to the handler by the ASP.NET runtime. 
</p>

<h4>Implementing the Service</h4>

<p>
XmlRpcService is derived from, adding the custom application function of the 
Service. The derived class contains one or more public methods which represent 
the required XML-RPC methods. For example, the SumAndDifference example would 
be implemented like this: 
</p>

<pre>using System; 
using CookComputing.XmlRpc; 

struct SumAndDiffValue 
{ 
  public int sum; 
  public int difference; 
}
 
class SumAndDiffService : XmlRpcService
{ 
  [XmlRpcMethod(&quot;sample.sumAndDifference&quot;)] 
  public SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    SumAndDiffValue ret; 
    ret.sum = x + y; 
    ret.difference = x – y; 
    return ret; 
  } 
} </pre>

<p>
If this code is saved to a file called sumanddiff.cs the Service can be built 
using the following command line: 
</p>

<pre>csc /r:system.web.dll /r:CookComputing.XmlRpc.dll /target:library sumanddiff.cs  </pre>

<p>
This will build a dll assembly called sumanddiff.dll. 
</p>

<h4>Configuring the Service</h4>

<p>
The Service has to be placed in a virtual directory, say xmlrpc in this case, 
which has a sub-directory called bin. A configuraton file called web.config 
is created in the virtual root directory containing the following information 
to specify that the Service should be invoked when a HTTP request arrives for 
this URL: </p>
<pre>&lt;configuration&gt;
  &lt;system.web&gt; 
    &lt;httpHandlers&gt;
      &lt;add verb=&quot;*&quot; path=&quot;SumAndDiff.rem&quot; 
         type=&quot;SumAndDifference, sumanddiff&quot; /&gt;
    &lt;/httpHandlers&gt;
  &lt;/system.web&gt;
&lt;configuration&gt;</pre>

<p>
The config file specifies that if the final segment of the URL is SumAndDiff.rem 
the handler in the class SumAndDifference will be invoked. Note that the assembly 
qualified name of the class is used so that ASP.NET knows which assembly to 
load the class from. 
</p>

<p>
The HTTP verb is specified by a wildcard. The implementation in XmlRpcService 
handles both POST for XML-RPC method calls and GET to return an automatically 
generated documentation on the Service. XmlRpcService will reject any other 
requests with the appropriate HTTP response code. 
</p>

<p>
The extension used for the URL is “.rem”. This is for convenience because ASP.NET 
is configured by default to handle a number of extensions including .rem, .aspx, 
and .asmx. Other extensions could be used, for example .xmlrpc would be an obvious 
choice, but this involves changing the configuration of the virtual directory 
via the IIS management snap-in. 
</p>

<p>
Once the service is configured a quick check can be made by pointing your browser 
at the URL and verifying that the automatically generated help page is displayed.
</p>

<h3><a name="3.3"></a>3.3 How do I implement an XML-RPC server using .NET Remoting?</h3>

<p>XML-RPC.NET includes a Remoting formatter sink provider, the class 
XmlRpcServerFormatterSinkProvider. When configured this enables the Remoting 
infrastructure to handle incoming XML-RPC requests as well as SOAP requests. 
</p>

<pre>using System;
using System.Runtime.Remoting;
using CookComputing.XmlRpc;

public struct SumAndDiffValue 
{ 
  public int sum; 
  public int difference; 
}

public class SumAndDiff : MarshalByRefObject 
{ 
  [XmlRpcMethod("sample.sumAndDifference")] 
  public SumAndDiffValue SumAndDifference(int x, int y) 
  { 
    SumAndDiffValue ret; 
    ret.sum = x + y; 
    ret.difference = x - y; 
    return ret; 
  } 
} 
</pre>

<p>
Note that instead of deriving the service class from XmlRpcService, it is now 
derived from MarshalRefByObject.<br/>
</p>

<pre>class XmlRpcServer

{
  static void Main(string[] args) 
  { 
    RemotingConfiguration.Configure("SumAndDiff.exe.config"); 
    RemotingConfiguration.RegisterWellKnownServiceType(
	  typeof(SumAndDiff), 
      "SumAndDiff.rem",
      WellKnownObjectMode.Singleton); 
    Console.WriteLine("Press to shutdown"); 
    Console.ReadLine(); 
  } 
}</pre>

<p>
A config file is needed to specify that the Remoting infrastructure uses the 
XML-RPC.NET formatter:
</p>

<pre>&lt;configuration&gt; 
  &lt;system.runtime.remoting&gt;
    &lt;application&gt;      
      &lt;channels&gt;         
        &lt;channel ref=&quot;http&quot; port=&quot;5678&quot;&gt;
          &lt;serverProviders&gt;<br/>            &lt;formatter<br/>  type=&quot;CookComputing.XmlRpc.XmlRpcServerFormatterSinkProvider, CookComputing.XmlRpc&quot; 
            /&gt;            
            &lt;formatter ref=&quot;soap&quot; /&gt;       
          &lt;/serverProviders&gt;
        &lt;/channel&gt;
      &lt;/channels&gt;
    &lt;/application&gt;   
  &lt;/system.runtime.remoting&gt; 
&lt;/configuration&gt;</pre>

<p>
Note that the default SOAP formatter is the second formatter so that if the 
XML-RPC formatter does not recognize the request it can pass the request onto 
the next formatter. The file also specifies that the server listens on port 
5678.</p>


<h3><a name="3.4"></a>3.4 How do I implement an XML-RPC server in IIS using .NET Remoting</h3>

<p>
A virtual directory is created and the assemblies placed in a sub-directory 
called <b>bin</b>. The config file is called <b>web.config</b> in this case 
and specifies two aspects of the server: the service element specifies the server 
class and its URL, and the channels element specifies that two formatters are 
supported, the default SOAP formatter and the XML-RPC formatter.
</p>

<pre>&lt;configuration&gt; 
  &lt;system.runtime.remoting&gt; 
    &lt;application&gt; 
      &lt;service&gt; 
        &lt;wellknown mode=&quot;Singleton&quot;    
                   type=&quot;SumAndDifference, sumanddiff&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       &nbsp;     objectUri=&quot;SumAndDiff.rem&quot; /&gt; 
      &lt;/service&gt; 
      &lt;channels&gt; 
        &lt;channel ref=&quot;http&quot;&gt;    
          &lt;serverProviders&gt;    
            &lt;formatter    
type=&quot;CookComputing.XmlRpc.XmlRpcServerFormatterSinkProvider, CookComputing.XmlRpc&quot; /&gt; 
            &lt;formatter ref=&quot;soap&quot; /&gt; 
          &lt;/serverProviders&gt;    
        &lt;/channel&gt;  
      &lt;/channels&gt; 
    &lt;/application&gt; 
  &lt;/system.runtime.remoting&gt; 
&lt;/configuration&gt; </pre>

<p>
Obviously the URL used by the client should be changed to connect to IIS, for 
example:
</p>

<pre>SumAndDifference svr = (SumAndDifference)Activator.GetObject(
  typeof(SumAndDifference), <br/>  &quot;http://localhost/xmlrpc/SumAndDiff.rem&quot;);</pre>


<h3><a name="3.5"></a>3.5 Do XML-RPC.NET servers implement the XML-RPC Introspection API?</h3>

<p>
The base class for implementing all types of XML-RPC server is XmlRpcServerProtocol. 
This implements the Introspection API and so all XML-RPC.NET endpoints automatically 
expose this API. 
</p>


<h3><a name="3.6"></a>3.6 What is Automatic Documentation?</h3>

<p>
XmlRpcHttpServerProtocol is the base class for implementing an XML-RPC endpoint 
in an HTTP server. This class handles GET requests by dynamically generating 
a help page for the endpoint using reflection.
</p>

<p>
The following attributes each take an optional named parameter called <b>Description</b> 
  in their constructor:
</p>

<p>- XmlRpcService<br/>
  - XmlRpcMethod<br/>
  - XmlRpcParameter<br/>
  - XmlRpcReturnValue
</p>

<p>
The automatic documentation is generated using the method names of the class, 
the parameter types, and the values of the <b>Description</b> property of all 
attributes which hae been defined.
</p>


<h3><a name="3.7"></a>3.7 How do I support authentication in my XML-RPC service?</h3>

<p>
Authentication is not provided by standalone .NET Remoting and if required 
must be implemented by the developer. On the other hand IIS does support authentication 
and so the two IIS-based methods on implementing servers can be used where authentication 
is required. Configuration is exactly the same as for normal web pages and 
is described in the IIS online documentation.
</p>

<h3><a name="3.8"></a>3.8 Can I implement a server which supports both XML-RPC and SOAP?</h3>

<p>
Yes, if using .NET Remoting and the soap formatter is configured as well as 
the XML-RPC formatter, the server will handle both XML-RPC and SOAP requests.
</p>

<pre>&lt;configuration&gt; <br/>  &lt;system.runtime.remoting&gt; <br/>    &lt;application&gt; <br/>      &lt;channels&gt; <br/>        &lt;channel ref=&quot;http&quot; port=&quot;5678&quot;&gt; <br/>          &lt;serverProviders&gt;<br/>            &lt;formatter<br/>type=&quot;CookComputing.XmlRpc.XmlRpcServerFormatterSinkProvider, CookComputing.XmlRpc&quot; 
            /&gt;            
            &lt;formatter ref=&quot;soap&quot; /&gt;       
          &lt;/serverProviders&gt; <br/>        &lt;/channel&gt; <br/>      &lt;/channels&gt; <br/>    &lt;/application&gt; <br/>  &lt;/system.runtime.remoting&gt; <br/>&lt;/configuration&gt;</pre>

<h3><a name="3.9"></a>3.9 Can I run XML-RPC.NET services with other web servers?</h3>

<p>
Yes - as long as the web server supports ASP.NET. This is not as implausible 
as it might sound because it is fairly easy to host ASP.NET using the .NET implementation 
of System.Web.Hosting. An example of this is the <a href="http://www.asp.net/Projects/Cassini/Download/">Cassini 
Web Serve</a>r implemented by the ASP.NET team.
</p>

<p>
One point worth mentioning when running Cassini is that assemblies by default 
must be placed in a directory called <b>bin</b> under the virtual root. For 
example, if the URL of the service is <b>http://localhost/xmlrpc/math.rem</b> 
assemblies are loaded from virtual<b> /bin</b> and not virtual <b>/xmlrpc/bin</b>. 
In this example the config file is placed in the virtual <b>/xmlrpc</b> directory 
and would look like this:
</p>

<pre>
&lt;configuration&gt;
  &lt;system.web&gt;
    &lt;httpHandlers&gt;
      &lt;add verb=&quot;*&quot; path=&quot;math.rem&quot; type=&quot;MathService, MathService&quot; /&gt;
    &lt;/httpHandlers&gt; 
  &lt;/system.web&gt;
&lt;/configuration&gt;
</pre>


<h3><a name="3.10"></a>3.10 Can I implement Services in other languages?</h3>

<p>
Services can be implemented in any CLS compliant language as the samples in 
this section illustrate.
</p>

<h4>VB.NET</h4>

<pre>Imports CookComputing.XmlRpc

Public Structure SumAndDiffValue
  Public sum As Integer
  Public difference As Integer
End Structure


Public Class SumAndDiffService
  Inherits XmlRpcService


 &lt;XmlRpcMethod(&quot;sample.sumAndDifference&quot;)&gt; _
 Public Function SumAndDifference(ByVal x As Integer, _
                                  ByVal y As Integer) _
                                  As SumAndDiffValue
   Dim ret As SumAndDiffValue
   ret.difference = x - y
   ret.sum = x + y
   Return ret
 End Function

End Class
</pre>


<h3><a name="3.11"></a>3.11 Can I implement a service in an ASHX file?</h3>

<p>
ASHX files provide a very simple way to deploy XML-RPC services without building assemblies 
and configuring a web.config file. Create a file like this with a .ashx extension and place 
it in a web directory which has a sub-directory called bin containing CookComputing.XmlRpc assembly: 
<pre>
&lt;%@ WebHandler Language= "VB" Class="Test" %&gt;
&lt;%@ Assembly Name="CookComputing.XmlRpc" %&gt;

Imports CookComputing.XmlRpc

&lt;XmlRpcService&gt; _
Public Class Test Inherits XmlRpcService
    &lt;XmlRpcMethod&gt; _
    Public Function Foo(ByVal x as Integer) As Integer
        Return x * x
    End Function
End Class
</pre>
ASHX web handlers can be written in C# a similar way.
</p>



<h2>4. Error Handling</h2>


<h3><a name="4.1"></a>4.1 How are XML-RPC Fault Responses represented?</h3>

<p>
An XML-RPC Fault Response contains a struct with two members: a fault code 
and a fault description:
</p>

<pre>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;methodResponse&gt;
  &lt;fault&gt;
    &lt;value&gt;
      &lt;struct&gt;
        &lt;member&gt;
          &lt;name&gt;faultCode&lt;/name&gt;
          &lt;value&gt;&lt;int&gt;4&lt;/int&gt;&lt;/value&gt;
        &lt;/member&gt;
        &lt;member&gt;
          &lt;name&gt;faultString&lt;/name&gt;
          &lt;value&gt;&lt;string&gt;Too many parameters.&lt;/string&gt;&lt;/value&gt;
        &lt;/member&gt;
      &lt;/struct&gt;
    &lt;/value&gt;
  &lt;/fault&gt;
&lt;/methodResponse&gt;</pre>

<p>
XML-RPC.NET maps Fault Responses onto .NET exceptions, more specifically a 
type called XmlRpcFaultException. This is derived from System.ApplicationException 
and contains two properties: int FaultCode and string FaultDescription. Server 
application code simply throws an instance of this exception where required 
and XML-RPC.NET catches it and returns it as a Fault Response. For example:
</p>

<pre>throw new XmlRpcFaultException(100, &quot;Invalid argument&quot;); </pre>

<p>
On the client side XML-RPC.NET receives the Fault Response, extracts the code 
and description, and throws a corresponding instance of XmlRpcFaultException. 
Client code can catch this exception using a try-catch block. For example:
</p>

<pre>SumAndDiffProxy sdprxy = new SumAndDiffProxy();
try
{
  SumAndDiffValue ret = sdprxy-&gt;SumAndDifference(2, 3);
}
catch (XmlRpcFaultException fex)
{
  Console.WriteLine(&quot;Fault Response: {0} {1}&quot;, 
    fex.FaultCode, fex.FaultString);
}</pre>


<h3><a name="4.2"></a>4.2 How are other types of error returned?</h3>

<p>
Error conditions can occur at other stages of an XML-RPC call. These fall into 
two categories, the first being networking errors, for example the client failing 
to connect to the server because the URL is invalid or the server is down. The 
second category is where the XML-RPC request reaches the server but cannot be 
processed for some reason, for example because it is not a valid XML-RPC request 
or the server application code crashes while processing the request. 
</p>

<p>
Unfortunately XML-RPC does not provide a way of differentiating between an 
application level error and a protocol level or internal error, for example 
if the request is not a valid XML-RPC request. One approach is to define a well-known 
set of error codes which will be used by all XML-RPC implementations but this 
suffers from the drawback that this set of error codes cannot be guaranteed 
to never conflict with the error codes that application code may need to return. 
Application code can certainly choose its own error codes but may also need 
to return error codes from third party code, for example from a database. 
</p>

<p>
Currently XML-RPC.NET returns a fault code of zero when a protocol or internal 
error occurs, leaving all other error codes available for application level 
error reporting.
</p>

<h3><a name="4.3"></a>4.3 What happens if the return value of a proxy method is incorrect?</h3>

<p>
If a proxy method is defined to return the wrong data type an instance of XmlRpcTypeMismatchException 
is thrown when the response is parsed. For example, if the sample.SumAndDifference 
proxy method was incorrectly defined to return a string:
</p>

<pre>[XmlRpcMethod] 
string SumAndDifference(int x, int y) 
{ 
  return (string)Invoke("SumAndDifference", 
                                 new Object[]{ x, y }); 
} </pre>

<p>
an instance of XmlRpcTypeMismatchException would be thrown, containing the 
message &quot;param element contains unexpected struct element&quot;. This is 
because the XML-RPC response contains a struct but the deserializer is expecting 
a string (it knows this from reflecting on the return value of the proxy method).
</p>


<h2>5. Debugging</h2>


<h3><a name="5.1"></a>5.1 How do I monitor XML-RPC calls across the network?</h3>

<p>
A very useful tool for monitoring the HTTP requests and responses associated 
with an XML-RPC call is <b><a href="http://www.pocketsoap.com/tcptrace/">tcptrace</a>.</b> 
This enables you to view the headers and content of HTTP requests. Configure 
it to use an unused port on your machine and set the destination server and 
destination port to those of the XML-RPC endpoint. Point your client at the 
local port you have chosen and all XML-RPC requests will pass through tcptrace, 
which will display in particular the request and response XML documents.
</p>


<h3><a name="5.2"></a>5.2 How do I debug an XML-RPC.NET service?</h3>

<p>
XML-RPC.NET services under IIS run within the aspnet_wp.exe process and so 
must be debugged by attaching a debugger to this process.
</p>

<h4>Using the SDK Debugger</h4>

<p>
To attach to aspnet_wp.exe from the .NET SDK debugger - <b>dbgclr.exe</b> - 
perform these steps:</p>

<ol>
  <li>Call the service to ensure aspnet_wp.exe is running and the service is loaded.</li>
  <li>Launch the debugger.</li>
  <li> Use the <b>File...Open File</b> menu item to open the source file for the 
    page you want to debug.</li>
  <li>From the <b>Tools</b> menu, choose <b>Debug Processes</b>. Check the <b>Show</b> 
    system processes checkbox, if it is not checked (this may not be necessary, 
    depending on the account aspnet_wp.exe is running under).</li>
  <li>Find the aspnet_wp.exe process and double-click it to attach to it.</li>
  <li>Close the <b>Processes</b> dialog. </li>
</ol>

<p>
To debug the service, place breakpoints in the source file and call the service.
</p>

<h4>Using the Visual Studio .NET Debugger</h4>

<p>
To attach to aspnet_wp.exe from Visual Studo .NET, perform the following steps:
</p>

<ol>
  <li>Call the service to ensure aspnet_wp.exe is running and the service is loaded.</li>
  <li>Open the project which implements the service you want to debug.</li>
  <li>From the <b>Debug</b> menu, choose <b>Processes</b>.</li>
  <li>Find the aspnet_wp.exe process and double-click it</li>
  <li>Check <b>Common Language Runtime</b> on the <b>Attach to Process</b> dialog 
    which then appears and click <b>OK</b>. (It is ok to leave <b>Native</b> checked.)</li>
  <li>Close the <b>Processes</b> dialog.</li>
</ol>

<p>
To debug the service, place breakpoints in the source file and call the service.
</p>

<p><b>Using Cassini</b></p>

<p>
The easiest method of debugging a service is to use the <a href="http://www.asp.net/Projects/Cassini/Download/">Cassini</a> 
web server. In either the SDK debugger or Visual Studio set the program to be 
run as the Cassini executable and set the arguments as required by Cassini, 
  <physical-path> <port> <virtual-path><b>&lt;physical-path&gt; &lt;port&gt; &lt;virtual-path&gt;</b>, 
  for example:<physical-path> <port> <virtual-path><physical-path> <port> <virtual-path><physical-path> 
  <port> <virtual-path> <physical-path> <port> <virtual-path> <physical-path> 
  <port> <virtual-path> 
</p>

<p>
<b>c:\cassini\wwwroot &nbsp;&nbsp;82&nbsp;&nbsp;/</b>
</p>

<p>
Set breakpoints and then select <b>Debug..Start</b> or hit <b>F5</b>. The advantage 
of using Cassini is that you don't have to re-attach the debugger each time 
you rebuild the service.
</p>


<h2>6. Miscellaneous</h2>


<h3><a name="6.1"></a>6.1 Which XML Encodings are Supported? </h3>

<p>
XML-RPC.NET uses compliant XML parsers and writers. It outputs XML in the UTF-8 
encoding by default and accepts various encodings when reading XML, for example 
UTF-8, UTF-16, ISO-8859-1, etc.
</p>

<p>
String handling in XML-RPC is problematic because the XML-RPC standard is inconsistent 
in this area. XML-RPC.NET handles the issue by specifying that the string value 
element can contain any Unicode character which can be contained in XML text 
content.
</p>

<p>When sending a request it is possible to specify the encoding by setting the 
XmlEncoding property of the proxy class. For example:</p>

<pre>SumAndDiffProxy proxy = new SumAndDiffProxy();
proxy.XmlEncoding = new System.Text.ASCIIEncoding();
SumAndDiffValue ret = proxy.SumAndDifference(2, 3);</pre>

<p>
Refer to the .NET Framework documentation for the encodings that are supported. 
</p>


<h3><a name="6.2"></a>6.2 Which Code Access Security Permissions are Required?</h3>

<p>
XML-RPC.NET needs a minimal set of Code Access Security (CAS) permissions, 
in particular networking permission to connect to a server. In the case of downloadable 
smart clients this could be restricted to connecting to the server from which 
the client was downloaded. 
</p>


<h3><a name="6.3"></a>6.3 Why is the key file not included in the distribution?</h3>

<p>
Building XML-RPC.NET from the distribution will fail because of a missing file 
called <b>CookComputing.key</b>. This contains the public/private key pair used 
to sign the CookComputing.XmlRpc.dll assembly with a strong name. The file is 
not distributed because this would enable anyone else to build a malicious version 
of the assembly and pass it off as originating from Cook Computing. 
</p>

<p>
To generate your own key file using the sn.exe tool as follows:
</p>

<pre>sn -k mykeyfile.snk</pre>

<p>
and modify the relevant line in assemblyinfo.cs:
</p>

<pre>[assembly: AssemblyKeyFile("mykeyfile.snk")]
</pre>

<p>
Alternatively, comment out this line if you do not need to sign your assembly 
with a strong name.<br/>
</p>


<h3><a name="6.4"></a>6.4 How do I verify an XML-RPC.NET assembly is genuine?</h3>

<p>
Use the sn.exe tool to extract the public key token from the assembly:
</p>

<pre>sn -T cookcomputing.xmlrpc.dll</pre>

<p>
The token should be the same as this if the assembly was built using the Cook 
Computing key file:
</p>

<pre>a7d6e17aa302004d
</pre>


<h3><a name="6.5"></a>6.5 Can I define an interface from which both the proxy and server classes are derived?</h3>

<p>
Yes, as of version 0.7.0 of XML-RPC.NET this works. 
</p>


<h3>7. Resources</h3>

<h3><a name="7.1"></a>7.1 XML-RPC Specification</h3>

<p>
Dave Winer's XML-RPC specification is available <a href="http://www.xmlrpc.com/spec">here</a>. 
</p>

<h3><a name="7.2"></a>7.2 Books and Tutorials</h3>

<p>
The following book is worth reading if you are working with XML-RPC. As well 
as clearing up some of the issues in the spec it includes chapters on several 
of the XML-RPC toolkits.
</p>

<p>
<a href="http://www.amazon.com/exec/obidos/ASIN/0596001193/cookcomputing-20">Programming 
Web Services with XML-RPC</a> - Simon St. Laurent, Edd Dumbill, Joe Johnston 
(O'Reilly) 
</p>

<h3><a name="7.3"></a>7.3 Websites</h3>

<p>
<a href="http://www.xml-rpc.com/">XML-RPC.Com</a> - specfications, implementations, 
  services, etc.
</p>

<p>
<a href="http://www.xml-rpc.net/">XML-RPC.NET Site</a> 
  - home of XML-RPC.NET
</p>


<h3><a name="7.4"></a>7.4 Mailing Lists</h3>

<p>
There are two relevant Yahoo groups:
</p>

<p>
<a href="http://groups.yahoo.com/group/xml-rpc/">xml-rpc</a> - &quot; This 
list provides a forum for discussing and implementing the XML-RPC specification 
as a cross-platform protocol.&quot;
</p>

<p>
<a href="http://groups.yahoo.com/group/XMLRPCNET/">XMLRPCNET</a> - &quot;Discussion 
  of the XML-RPC.NET library.&quot;
</p>

<h3><a name="7.5"></a>7.5 Articles and Tutorials</h3>

<p>
Eric Kidd's <a href="http://xmlrpc-c.sourceforge.net/xmlrpc-howto/xmlrpc-howto.html">XML-RPC 
HOWTO</a> provides useful information on implementing clients and servers in 
a variety of languages.
</p>

<h3><a name="7.6"></a>7.6 Sample Services</h3>

<p>
The <a href="http://www.xml-rpc.net/doc/xmlrpcdemos.html">XML-RPC.NET Demos</a> page contains links to some XML-RPC services implemented using
XML-RPC.NET.
</p>

</body>
</html>
